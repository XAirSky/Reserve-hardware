// McdKeysDlg.cpp : implementation file
//

#include "stdafx.h"
#include "McdKeys.h"
#include "McdKeysDlg.h"
#include "Keys.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
static char THIS_DATE[] = __DATE__;
static char THIS_TIME[] = __TIME__;
#endif



#define LPT1
#define MATKB_COL0              0x1D 
#define MATKB_COL1              0x1B 
#define MATKB_COL2              0x17 
#define MATKB_COL3				0x0F

#ifdef  LPT1
#define COL_WRITE_PORT			0x378
#define ROW_READ_PORT			0x379
#endif

#ifdef  LPT2
#define COL_WRITE_PORT			0x278
#define COL_READ_PORT			0x279
#endif

#define MIN_COL_VAL				0x01
#define MAX_COL_VAL			    0x04
#define DEFAULT_ROW_VAL			0x7F
//#define COL_NUM_DRIVEN          0x03

/*Identification of Timer Objects*/
#define KB_TMR_ID1			  1
#define KB_TMR_ID2			  2

#define KB_TMR_1MS			  1
#define KB_TMR_2MS			  2
#define KB_TMR_5MS			  5

#define KB_TMR_25MS          25/* Elan Value 0x04 */ /* 25.4 ms +/- 0.5ms */
#define KB_TMR_33MS          33/* Elan Value 0x06 */ /* 33.2 ms +/- 0.5ms */
#define KB_TMR_37MS          37/* Elan Value 0x07 */ /* 37.2 ms +/- 0.5ms */
#define KB_TMR_41MS          41/* Elan Value 0x08 */ /* 41.1 ms +/- 0.5ms */
#define KB_TMR_45MS          45/* Elan Value 0x09 */ /* 45.0 ms +/- 0.5ms */
#define KB_TMR_49MS          49/* Elan Value 0x0A */ /* 48.9 ms +/- 0.5ms */
#define KB_TMR_53MS          53/* Elan Value 0x0B */ /* 52.8 ms +/- 0.5ms */
#define KB_TMR_57MS          57/* Elan Value 0x0C */ /* 56.7 ms +/- 0.5ms */
#define KB_TMR_61MS          61/* Elan Value 0x0D */ /* 60.6 ms +/- 0.5ms */
#define KB_TMR_68MS          68/* Elan Value 0x0F */ /* 68.4 ms +/- 0.5ms */
#define KB_TMR_72MS          72/* Elan Value 0x10 */ /* 72.3 ms +/- 0.5ms */
#define KB_TMR_76MS          76/* Elan Value 0x11 */ /* 76.3 ms +/- 0.5ms */
#define KB_TMR_84MS          84/* Elan Value 0x13 */ /* 84.1 ms +/- 0.5ms */
#define KB_TMR_92MS          92/* Elan Value 0x15 */ /* 91.9 ms +/- 0.5ms */
#define KB_TMR_100MS        100/* Elan Value 0x17 */ /* 99.7 ms +/- 0.5ms */
#define KB_TMR_111MS        111/* Elan Value 0x1A */ /* 111.4 ms +/- 0.5ms */
#define KB_TMR_123MS        123/* Elan Value 0x1D */ /* 123.2 ms +/- 0.5ms */
#define KB_TMR_143MS        143/* Elan Value 0x22 */ /* 142.7 ms +/- 0.5ms */
#define KB_TMR_166MS        166/* Elan Value 0x28 */ /* 166.2 ms +/- 0.5ms */
#define KB_TMR_201MS        201/* Elan Value 0x31 */ /* 201.4 ms +/- 0.5ms */
#define KB_TMR_248MS        248/* Elan Value 0x3D */ /* 248.3 ms +/- 0.5ms */
#define KB_TMR_334MS        334/* Elan Value 0x53 */ /* 334.3 ms +/- 0.5ms */
#define KB_TMR_499MS        499/* Elan Value 0x7D */ /* 498.5 ms +/- 0.5ms */
#define KB_TMR_749MS        749/* Elan Value 0xBD */ /* 748.8 ms +/- 0.5ms */
#define KB_TMR_999MS        999/* Elan Value 0xFD */ /* 999.0 ms +/- 0.5ms */


/* Characters supported by keypad in both Numeric and Alpha modes */
#define CHAR_ENTER            '\r'     /* <CR> Carriage Return */
#define CHAR_CANCEL           '\x1B'   /* <ESC> Escape                  */
#define CHAR_POWER            '\x18'   /* <CAN> Used for power button.  */

/* Characters not generated by keypad */
#define CHAR_NULL             '\0'
#define CHAR_BACKSPACE        '\x08'   /* <BS> Back Space      */
#define CHAR_SPACE            '\x20'   /* <SP> Space           */

#define CHAR_ZERO             '0'
#define CHAR_ONE              '1'
#define CHAR_TWO              '2'
#define CHAR_THREE            '3'
#define CHAR_FOUR             '4'
#define CHAR_FIVE             '5'
#define CHAR_SIX              '6'
#define CHAR_SEVEN            '7'
#define CHAR_EIGHT            '8'
#define CHAR_NINE             '9'

#define CHAR_DOT              '.'
#define CHAR_LESS_THAN        '<'
#define CHAR_GRTR_THAN        '>'

/* Characters supported in Alpha mode only */
#define CHAR_A                'A'
#define CHAR_B                'B'
#define CHAR_C                'C'
#define CHAR_D                'D'
#define CHAR_E                'E'
#define CHAR_F                'F'
#define CHAR_G                'G'
#define CHAR_H                'H'
#define CHAR_I                'I'
#define CHAR_J                'J'
#define CHAR_K                'K'
#define CHAR_L                'L'
#define CHAR_M                'M'
#define CHAR_N                'N'
#define CHAR_O                'O'
#define CHAR_P                'P'
#define CHAR_Q                'Q'
#define CHAR_R                'R'
#define CHAR_S                'S'
#define CHAR_T                'T'
#define CHAR_U                'U'
#define CHAR_V                'V'
#define CHAR_W                'W'
#define CHAR_X                'X'
#define CHAR_Y                'Y'
#define CHAR_Z                'Z'


#define KB_TMR_INTR_INTERVAL		    	KB_TMR_5MS
#define	KB_TMR_DEBOUNCE_INTERVAL        	KB_TMR_25MS + 4
#define KB_TMR_RELEASE_SCAN_INTERVAL		KB_TMR_248MS
#define	KB_TMR_TYPEMATIC_INTERVAL	        KB_TMR_25MS //KB_TMR_100MS
#define	KB_TMR_TYPEMATIC_REPEAT_INTERVAL	KB_TMR_499MS //KB_TMR_100MS
#define KB_TMR_CHAR_INDEX_POLL_INTERVAL	    KB_TMR_25MS //KB_TMR_100MS

/*Ideal. Only after I get the development board*/
#define MATKB_COL0              0x01
#define MATKB_COL1              0x02
#define MATKB_COL2              0x04
#define MATKB_COL3              0x08
#define MATKB_COL4              0x10
#define MATKB_COL5              0x20
#define MATKB_COL6              0x40
#define MATKB_COL7              0x80


#define CSC_KEYB_ROWA           0xC8   


#define MATKB_ROW0              0x01
#define MATKB_ROW1              0x02
#define MATKB_ROW2              0x04
#define MATKB_ROW3              0x08
#define MATKB_ROW4              0x10
#define MATKB_ROW5              0x20
#define MATKB_ROW6              0x40
#define MATKB_ROW7              0x80

#define KEYB_TIMER_DEBOUNCE                     KEYB_TIMER_25MS

/* Typematic Repeat                                                           */
/* Ref Keyboard Interface 16.3.1.5 Keyboard Timer                             */
/* PC/AT standard for typematic support requires a Typematic Delay of         */
/* between 250ms and 1000ms in increments of 250ms, and a Typematic Period    */
/* of 2 to 30 characters per second. i.e. 33 to 500ms per character           */

/* Interval between successive scans when checking for typematic delay        */
#define KEYB_TIMER_TYPEM_DELAY_SCAN_PERIOD      KEYB_TIMER_25MS

/* Character Indexing                                                         */
/* The maximum time interval between the release press of the same key        */
/* that will cause character indexing is the product of the values            */
/* KEYB_TIMER_CHAR_INDEX_PERIOD and MAX_CHAR_INDEX_POLLS.                     */

/* Interval between successive scans when checking for character index        */
#define KEYB_TIMER_CHAR_INDEX_PERIOD         KEYB_TIMER_25MS
/* Maximum number of character index scans that will be performed at an       */
/* interval of KEYB_TIMER_CHAR_INDEX_PERIOD.                                  */
#define MAX_CHAR_INDEX_POLLS                 40

/* Key Release                                                                */
/* Interval between successive scans when checking for key release            */
#define KEYB_TIMER_RELEASE_SCAN_PERIOD    KEYB_TIMER_25MS

/* For the application, keep the data type t_key_fifo local.               */
/* Define a FIFO to hold the keypad output.                                */
/* When the FIFO is full, additional key-presses are discarded             */
/* Use a buffer that can hold the maximum number of characters that the    */
/* keypad can generate in one second. i.e. max typematic repetition rate.  */
#define KEY_BUFFER_LENGTH     2


typedef enum
{
   KEY_TYPEM_REPEAT_2_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_3_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_4_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_5_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_6_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_7_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_8_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_9_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_10_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_11_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_12_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_13_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_14_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_15_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_17_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_18_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_19_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_21_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_22_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_24_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_27_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_30_CHARS_PER_SEC,
   KEY_TYPEM_REPEAT_NUM_OPTIONS
}  tKeyRepeatRate;


typedef enum
{
   KEY_TYPEM_DELAY_250MS,
   KEY_TYPEM_DELAY_500MS,
   KEY_TYPEM_DELAY_750MS,
   KEY_TYPEM_DELAY_1000MS,
   KEY_TYPEM_DELAY_NUM_OPTIONS
}  tKeyRepeatDelay;


typedef enum 
{ 
   KEY_MODE_ALPHA,
   KEY_MODE_NUMERIC
} tKeyMode;

typedef enum 
{ 
   COL3_LOW,
   COL4_LOW,
   COL7_LOW,
   COL_NUM_DRIVEN
} tColDrive;

typedef enum
{
   ROW0_KEY,
   ROW1_KEY,
   ROW2_KEY,
   ROW3_KEY,
   ROW4_KEY,
   ROW14_KEY,     /* Used for power button. */
   ROW_NUM_READ
} tRowKey;

typedef enum 
{
   KEY_TIMER_OFF,
   KEY_TIMER_WAIT_DEBOUNCE,
   KEY_TIMER_CHAR_INDEX_POLL,
   KEY_TIMER_WAIT_TYPEMATIC_DELAY,
   KEY_TIMER_WAIT_TYPEMATIC_PERIOD,
   KEY_TIMER_WAIT_KEY_RELEASE
} tKeyTimerStatus;


typedef enum
{
	KB_TMR_OFF,
	KB_TMR_INTR,
	KB_TMR_DEBOUNCE_DELAY,
	KB_TMR_RELEASE_SCAN_DELAY,
	KB_TMR_TYPEMATIC_DELAY,
	KB_TMR_TYPEMATIC_REPEAT_DELAY,
	KB_TMR_CHAR_INDEX_POLL_DELAY
} tKbTimerState;

static tKbTimerState KbTimerState = KB_TMR_INTR;

typedef enum
{
	KB_EVENT_NONE,
	KB_EVENT_KEYPRESS,
	KB_EVENT_KEYRELEASE,
	KB_EVENT_TYPEMATIC_PRESS,
} tKbEvent;

static tKbEvent KbEvent = KB_EVENT_NONE;


/* Indices in to character set for each key */
typedef enum 
{
   KEY_CHAR_NUMERIC,       /* 0 */
   KEY_CHAR_ALPHA1,        /* 1 */
   KEY_CHAR_ALPHA2,        /* 2 */
   KEY_CHAR_ALPHA3,        /* 3 */
   KEY_CHAR_ALPHA4,        /* 4 */
   KEY_CHAR_MAX_PER_KEY    /* 5 */
} tKeyChar;

typedef struct
{
   UCHAR  keyChars[ KEY_CHAR_MAX_PER_KEY ]; /* key character set for this key      */
   tKeyChar maxCharIndex;                /* identifies last character in set    */
   BOOL typematicSupported;                 /* TRUE if typematic supported         */
} tKeyProps;

typedef struct
{
   USHORT chars_per_sec;
   UCHAR  keyBoardTimer;
} tKeyRate;


/* The keypad typematic delay is 'long' [250 to 1000ms] and will be made up   */
/* of a sequence of 'short' delays, each of duration                          */
/* KEYB_TIMER_TYPEM_DELAY_SCAN_PERIOD.                                        */
/* The members of t_key_delay are defined as follows:                         */
/* delay_ms - typematic delay expressed in milliseconds.                      */
/* num_scans - number of KEYB_TIMER_TYPEM_DELAY_SCAN_PERIODs required to      */
/* cause a total delay of delay_ms.                                           */

typedef struct
{
   USHORT delay_ms;
   USHORT numScans; 
} tKeyDelay;

typedef UCHAR tColScan;

typedef tColScan tScanResult[COL_NUM_DRIVEN];

static BOOL mKeyRepeatEnabled = TRUE;
static tKeyRepeatRate mKeyRepeatRate = KEY_TYPEM_REPEAT_15_CHARS_PER_SEC;
static tKeyRepeatDelay mKeyRepeatDelay = KEY_TYPEM_DELAY_500MS;

static tKeyMode mKeyMode = KEY_MODE_NUMERIC;
static tKeyChar mKeyCharIdx = KEY_CHAR_NUMERIC;
static UCHAR KeyCharIdx = 0;

//static tKeyProps mKeyCurrent;
tKeyProps mKeyCurrent;
static UCHAR mLastKeyDown = CHAR_NULL;

typedef struct 
{
   UCHAR read_idx;      /* next element of contents[] to be read        */
   UCHAR write_idx;     /* next element of contents[] to be written     */
   UCHAR contents[ KEY_BUFFER_LENGTH ];   /* keypad output characters   */
} tKeyFifo;

tKeyFifo mKeyBuff =
{
   0,                /* read_idx       */
   0,                /* write_idx      */
   { 
     ' ',     /* contents[0]    */
     ' ',     /* contents[1]    */
   },
};

UINT nReleaseCheck;

/* Initialise the properties of each key */
const static tKeyProps mKeyMap [COL_NUM_DRIVEN] [ROW_NUM_READ] = 
{

/*---------------------------------------------------------------------------*/
/*                         Keyboard Column 3                                 */
/*---------------------------------------------------------------------------*/

   {  /* Start of KBD_COL3 */ 

      /* KBD_COL3, KBD_ROW0 */
      {
         {
            CHAR_ONE,         /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_NUMERIC,    /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* KBD_COL3, KBD_ROW1 */
      {
         {
            CHAR_TWO,         /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_A,           /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_B,           /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_C,           /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_ALPHA3,     /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* KBD_COL3, KBD_ROW2 */
      {
         {
            CHAR_THREE,       /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_D,           /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_E,           /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_F,           /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_ALPHA3,     /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* KBD_COL3, KBD_ROW3 */
      {
         {
            CHAR_CANCEL,      /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_NUMERIC,    /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* KBD_COL3, KBD_ROW4 */
      {
         {
            CHAR_GRTR_THAN,   /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_NUMERIC,    /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* KBD_ROW14 - The Power Button */
      {
         {
            CHAR_POWER,       /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_NUMERIC,    /* max_char_index       */
         TRUE                 /* typematic_supported  */
      }

   }, /* End of KBD_COL3 */
   
/*---------------------------------------------------------------------------*/
/*                         Keyboard Column 4                                 */
/*---------------------------------------------------------------------------*/

   {  /* Start of KBD_COL4 */ 

      /* KBD_COL4, KBD_ROW0 */
      {
         {
            CHAR_FOUR,        /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_G,           /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_H,           /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_I,           /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_ALPHA3,     /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* KBD_COL4, KBD_ROW1 */
      {
         {
            CHAR_FIVE,        /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_J,           /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_K,           /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_L,           /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_ALPHA3,     /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* KBD_COL4, KBD_ROW2 */
      {
         {
            CHAR_SIX,         /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_M,           /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_N,           /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_O,           /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_ALPHA3,     /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* KBD_COL4, KBD_ROW3 */
      {
         {
            CHAR_DOT,         /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_NUMERIC,    /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* KBD_COL4, KBD_ROW4 */
      {
         {
            CHAR_ENTER,       /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_NUMERIC,    /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* NOT USED */
      {
         {
            0,                /* key_chars[ KEY_CHAR_NUMERIC ]       */
            0,                /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            0,                /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            0,                /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            0                 /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         (tKeyChar)0,                   /* max_char_index       */
         (tKeyChar)0                    /* typematic_supported  */
      }

   }, /* End of KBD_COL4 */
   
/*---------------------------------------------------------------------------*/
/*                         Keyboard Column 7                                 */
/*---------------------------------------------------------------------------*/

   {  /* Start of KBD_COL7 */ 

      /* KBD_COL7, KBD_ROW0 */
      {
         {
            CHAR_SEVEN,       /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_P,           /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_Q,           /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_R,           /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_S            /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_ALPHA4,     /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* KBD_COL7, KBD_ROW1 */
      {
         {
            CHAR_EIGHT,       /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_T,           /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_U,           /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_V,           /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_ALPHA3,     /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* KBD_COL7, KBD_ROW2 */
      {
         {
            CHAR_NINE,        /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_W,           /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_X,           /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_Y,           /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_Z            /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_ALPHA4,     /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* KBD_COL7, KBD_ROW3 */
      {
         {
            CHAR_ZERO,        /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_NUMERIC,    /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* KBD_COL7, KBD_ROW4 */
      {
         {
            CHAR_LESS_THAN,   /* key_chars[ KEY_CHAR_NUMERIC ]       */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         KEY_CHAR_NUMERIC,    /* max_char_index       */
         TRUE                 /* typematic_supported  */
      },

      /* NOT USED */
      {
         {
            0,                /* key_chars[ KEY_CHAR_NUMERIC ]       */
            0,                /* key_chars[ KEY_CHAR_ALPHA1 ]        */
            0,                /* key_chars[ KEY_CHAR_ALPHA2 ]        */
            0,                /* key_chars[ KEY_CHAR_ALPHA3 ]        */
            0                 /* key_chars[ KEY_CHAR_ALPHA4 ]        */
         },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
         (tKeyChar)0,                   /* max_char_index       */
         (tKeyChar)0                    /* typematic_supported  */
      }


   } /* End of KBD_COL7 */

}; /* End of m_key_map[] [] */


const static tKeyRate mKeyRepeat[ KEY_TYPEM_REPEAT_NUM_OPTIONS ] = 
{
   /* KEY_TYPEM_REPEAT_2_CHARS_PER_SEC */
   {
      2,
      KEYB_TIMER_499MS
   },

   /* KEY_TYPEM_REPEAT_3_CHARS_PER_SEC */
   {
      3,
      KEYB_TIMER_334MS
   },

   /* KEY_TYPEM_REPEAT_4_CHARS_PER_SEC */
   {
      4,
      KEYB_TIMER_248MS
   },

   /* KEY_TYPEM_REPEAT_5_CHARS_PER_SEC */
   {
      5,
      KEYB_TIMER_201MS
   },

   /* KEY_TYPEM_REPEAT_6_CHARS_PER_SEC */
   {
      6,
      KEYB_TIMER_166MS
   },

   /* KEY_TYPEM_REPEAT_7_CHARS_PER_SEC */
   {
      7,
      KEYB_TIMER_143MS
   },

   /* KEY_TYPEM_REPEAT_8_CHARS_PER_SEC */
   {
      8,
      KEYB_TIMER_123MS
   },

   /* KEY_TYPEM_REPEAT_9_CHARS_PER_SEC */
   {
      9,
      KEYB_TIMER_111MS
   },

   /* KEY_TYPEM_REPEAT_10_CHARS_PER_SEC */
   {
      10,
      KEYB_TIMER_100MS
   },

   /* KEY_TYPEM_REPEAT_11_CHARS_PER_SEC */
   {
      11,
      KEYB_TIMER_92MS
   },

   /* KEY_TYPEM_REPEAT_12_CHARS_PER_SEC */
   {
      12,
      KEYB_TIMER_84MS
   },

   /* KEY_TYPEM_REPEAT_13_CHARS_PER_SEC */
   {
      13,
      KEYB_TIMER_76MS
   },

   /* KEY_TYPEM_REPEAT_14_CHARS_PER_SEC */
   {
      14,
      KEYB_TIMER_72MS
   },

   /* KEY_TYPEM_REPEAT_15_CHARS_PER_SEC */
   {
      15,
      KEYB_TIMER_68MS
   },

   /* KEY_TYPEM_REPEAT_17_CHARS_PER_SEC */
   {
      17,
      KEYB_TIMER_61MS
   },

   /* KEY_TYPEM_REPEAT_18_CHARS_PER_SEC */
   {
      18,
      KEYB_TIMER_57MS
   },

   /* KEY_TYPEM_REPEAT_19_CHARS_PER_SEC */
   {
      19,
      KEYB_TIMER_53MS
   },

   /* KEY_TYPEM_REPEAT_21_CHARS_PER_SEC */
   {
      21,
      KEYB_TIMER_49MS
   },

   /* KEY_TYPEM_REPEAT_22_CHARS_PER_SEC */
   {
      22,
      KEYB_TIMER_45MS
   },

   /* KEY_TYPEM_REPEAT_24_CHARS_PER_SEC */
   {
      24,
      KEYB_TIMER_41MS
   },

   /* KEY_TYPEM_REPEAT_27_CHARS_PER_SEC */
   {
      27,
      KEYB_TIMER_37MS
   },

   /* KEY_TYPEM_REPEAT_30_CHARS_PER_SEC */
   {
      30,
      KEYB_TIMER_33MS
   }

}; /* m_key_repeat[] */


const static tKeyDelay mKeyDelay[ KEY_TYPEM_DELAY_NUM_OPTIONS ] = 
{

   /* KEY_TYPEM_DELAY_250MS */
   {
      250,
      10    
   },

   /* KEY_TYPEM_DELAY_500MS */
   {
      500,
      20,
   },

   /* KEY_TYPEM_DELAY_750MS */
   {
      750,
      30
   },

   /* KEY_TYPEM_DELAY_1000MS */
   {
      1000,
      40
   }

}; /* m_key_delay[] */

static void pause( void );

void keyOpenSession( void );

void keySetAlphaMode( void );

void keySetNumericMode( void );

void keyEnableRepeat( void );

void keyDisableRepeat( void );

BOOL keyRepeatIsEnabled( void );

void keySetRepeatDelay( tKeyRepeatRate repeatDelay );

UINT keyGetRepeatDelay( void );

void keySetRepeatRate( tKeyRepeatRate repeatRate );

UINT keyGetRepeatRate( void );

void keyFlush( void );

BOOL keyWaiting( void );

UCHAR keyRead( void );

void keyDiscard( void );

UCHAR keyGetLastDown( void );

UCHAR keyGetLastPressed( void );

void keyCloseSession( void );
void scanKeyPad(UCHAR *keyInfo);



/* inpout32.lib should be there for linking*/
short _stdcall Inp32(short PortAddress);
void  _stdcall Out32(short PortAddress, short data);

unsigned int KbdThread1(LPVOID param);
unsigned int KbdThread2(LPVOID param);


UCHAR colSet;
UCHAR colArr[4] = {0x1D, 0x1B, 0x17, 0x0F};
UINT toggle=0;
short keyVal[4];
UCHAR charVal;

UCHAR validChar =0;
BOOL  charAvailable = FALSE;
UCHAR prevChar;
UCHAR newChar;
UCHAR noChar;
UCHAR charRepeat;
UCHAR keypress_scan[MAX_COL_VAL + 1];
UCHAR debounce_scan[MAX_COL_VAL + 1];

//UCHAR str[50];
UINT strCounter;
char finalTextBuffer[1024];

/*Keyboard global flags*/
UINT flag1;



unsigned int KbdThread1(LPVOID param)
{
	while(1)
	{
		for(colSet = MIN_COL_VAL; colSet <= MAX_COL_VAL; colSet++)
		{
			Out32( COL_WRITE_PORT, colArr[colSet-1] );
			
			keyVal[colSet-1] = Inp32(ROW_READ_PORT);
			
						 
			if(keyVal[colSet-1] != DEFAULT_ROW_VAL)
			{
				charVal = ((char)keyVal[colSet-1] && 0xF8) | colSet;
				validChar =1;
				charVal = newChar;
				//writeBuffer(charVal);
				
				switch(charVal)
				{
					
				
				}
			}

			else
			{
				validChar =0;
			}
		}
	/*	
		if (toggle == 0)
		{
			toggle = 1;
			Out32(0x378, 0x03);
			keyVal = Inp32(0x379);
			if(keyVal == 111)
			{
			
			}
			
			else if (keyVal == 95)
			{
			flag1=1;
						}
			
			else if (keyVal == 127)
			{
			
			}
		}
		
		else if (toggle == 1)
		{
			toggle = 0;
			Out32(0x378, 0x05);
			keyVal = Inp32(0x379);
			if (keyVal == 111) 
			{
			
			}
			
			else if (keyVal == 95)
			{
			
			}
			
			else if (keyVal == 127)
			{
			
			}
		}*/
	
	}

	return 0;
}

unsigned int KbdThread2(LPVOID param)
{
	CWnd *pWnd = (CWnd*)param;

	CEdit *Edit = (CEdit*)pWnd->GetDlgItem(IDC_EDIT1);
	if(Edit)
	{
		Edit->SetWindowText(finalTextBuffer);
	}
	return 0;
}


static void writeBuffer( UCHAR write_char )
{
   UCHAR incremented_write_ptr = mKeyBuff.write_idx + 1;

   // record where the write pointer would be if it was incremented
   if (incremented_write_ptr == KEY_BUFFER_LENGTH) 
   {
      incremented_write_ptr = 0;
   }

   // if it now equals the read pointer the buffer is already full
 //  if (incremented_write_ptr != mKeyBuff.read_idx)
   {
      // Update the write pointer with the incremented value
      mKeyBuff.write_idx = incremented_write_ptr;
      // Add key-press to buffer
      mKeyBuff.contents[ mKeyBuff.write_idx ] = write_char;
   }
} /* write_buffer */

static void writeString( UCHAR write_char )
{
	finalTextBuffer[strCounter++] = write_char;
}
char readChar()
{
	/*
	UCHAR incremented_read_ptr = mKeyBuff.read_idx + 1;
    if (incremented_read_ptr == KEY_BUFFER_LENGTH) 
    {
      incremented_read_ptr = 0;
    }
	*/

	/*if(incremented_read_ptr != mKeyBuff.write_idx)
	{
		mKeyBuff.read_idx = incremented_read_ptr;
		return(mKeyBuff.contents[ mKeyBuff.read_idx]);
	}
	*/
	
	return(mKeyBuff.contents[ mKeyBuff.read_idx]);
}


class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

	// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMcdKeysDlg dialog

CMcdKeysDlg::CMcdKeysDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMcdKeysDlg::IDD, pParent)
{

	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	/*Start the threads one for Keypad scanning*/
	/*The other is for interpreting*/	
}

void CMcdKeysDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMcdKeysDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMcdKeysDlg, CDialog)
	//{{AFX_MSG_MAP(CMcdKeysDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_TIMER()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_START, OnStart)
	ON_BN_CLICKED(IDC_STOP, OnStop)
	ON_BN_CLICKED(IDC_BUTTON1, OnButton1)
	ON_BN_CLICKED(IDC_BUTTON2, OnButton2)
	
	//ON_NOTIFY(NM_RELEASEDCAPTURE, IDC_SLIDER1, OnReleasedcaptureSlider1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMcdKeysDlg message handlers

BOOL CMcdKeysDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	for(int k=0; k<1024; k++)
	{
		finalTextBuffer[k]=0;
	}


	CSliderCtrl *Ctl = (CSliderCtrl*)GetDlgItem (IDC_SLIDER1);
	if (Ctl)
	{
		Ctl->SetRange (0, 100);
	}

	Ctl = (CSliderCtrl*)GetDlgItem(IDC_SLIDER2);
	if(Ctl)
	{
		Ctl->SetRange(0, 100);
	}

	Ctl = (CSliderCtrl*)GetDlgItem(IDC_SLIDER3);
	if(Ctl)
	{
		Ctl->SetRange(0, 100);
	}
	
	CEdit *Edit = (CEdit*)GetDlgItem(IDC_EDIT1);
	if(Edit)
	{
		//AfxMessageBox("Found Text Box");
	}


	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	/*Create the timers for handling the debouncing
	and Typematic delays of the keyboard etc*/

/*	 m_th1 = AfxBeginThread ( KbdThread1, m_d ) ;
	 m_th2 = AfxBeginThread ( KbdThread2, this ) ;
*/

	KbTimerState = KB_TMR_INTR;
	SetTimer( KB_TMR_ID1, KB_TMR_INTR_INTERVAL, NULL );
	
	/*KbTimerState = KB_TMR_INTR;
	SetTimer( KB_TMR_ID1, KB_TMR_DEBOUNCE_INTERVAL, NULL );*/

	SetTimer( KB_TMR_ID2, KB_TMR_100MS, NULL );
		
	return TRUE;  
}

void CMcdKeysDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CMcdKeysDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
				CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width()  - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
// the minimized window.
HCURSOR CMcdKeysDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


void CMcdKeysDlg::OnStart() 
{

}

void CMcdKeysDlg::OnStop() 
{
 ::TerminateThread ( m_th1 -> m_hThread, 0 );
 ::TerminateThread ( m_th2 -> m_hThread, 0 );
	
}

void CMcdKeysDlg::OnButton1() 
{
/*m_th1 = AfxBeginThread ( KbdThread1, m_d ) ;
  m_th2 = AfxBeginThread ( KbdThread2, this ) ;*/
}

void CMcdKeysDlg::OnButton2() 
{
 AfxMessageBox("HELLO");	
}

static UCHAR keyPressScan[3];
static UCHAR debounceScan[3];
static UCHAR releaseScan[3];
static UCHAR typematicScan[3];
static UCHAR indexScan[3];

static tKeyProps keyPrevious = 
{
	{
		CHAR_NULL,        /* key_chars[ KEY_CHAR_NUMERIC ]       */
		CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA1 ]        */
        CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA2 ]        */
        CHAR_NULL,        /* key_chars[ KEY_CHAR_ALPHA3 ]        */
        CHAR_NULL         /* key_chars[ KEY_CHAR_ALPHA4 ]        */
    },                   /* key_chars[ KEY_CHAR_MAX_PER_KEY ]   */
    
	KEY_CHAR_NUMERIC,    /* max_char_index       */
    FALSE                /* typematic_supported  */
};


void CMcdKeysDlg::OnTimer(UINT ID)
{
	/*m_th1->SuspendThread();*/
   static UINT indexPollCount = 0;
   static UINT typematicPollCount = 0;

#if 0
   static tScanResult keyPressScan = { 0x00 };
   static tScanResult debounceScan = { 0x00 };
   static tScanResult releaseScan = { 0x00 };
   static tScanResult typematicScan = { 0x00 };
   static tScanResult indexScan = { 0x00 };
#endif

//#if 1
   /*
   static UCHAR keyPressScan[3];
   static UCHAR debounceScan[3];
   static UCHAR releaseScan[3];
   static UCHAR typematicScan[3];
   static UCHAR indexScan[3];
   */
//#endif


   UCHAR numColsPressed;
   UCHAR validOperation = FALSE;
   static BOOL charIndexSupported = FALSE;
   
   /* This is used to determine whether or not an initial NMI was generated   */
   /* by the power button.                                                    */
   static BOOL bPowerButton = FALSE;

   BOOL keyValid = FALSE;
   tColDrive colNum, colKey;
   tRowKey rowKey;

   /*Begin Identifying the timer object*/
   
   if (ID == KB_TMR_ID1)
	{

		switch(KbTimerState)
		{
		
		case KB_TMR_OFF:
			break;

		case KB_TMR_INTR:
			
			scanKeyPad(keyPressScan);
			for(colSet = MIN_COL_VAL; colSet <= MAX_COL_VAL; colSet++)
			{
				Out32( COL_WRITE_PORT, (UCHAR)colArr[colSet-1] | 0x01);
				
				pause();
				
				keyVal[colSet-1] = Inp32( ROW_READ_PORT );

				if( keyVal[colSet-1] != DEFAULT_ROW_VAL )
				{
					validOperation=TRUE;
					KbTimerState = KB_TMR_DEBOUNCE_DELAY;
					SetTimer( KB_TMR_ID1, KB_TMR_DEBOUNCE_INTERVAL, NULL );
				}
				
			}


			break;

		case KB_TMR_DEBOUNCE_DELAY:
			
			if ( bPowerButton )
            {
               // Yes it was. 

               // Reset the power button flag.                                         
               bPowerButton = FALSE;

               // Check if the button is still being pressed.                          
               // Replace this with IO code required.
			   // if ( elan_read_csc ( CSC_KEYB_ROWB ) & MATKB_SUS_RES )
               {
                  /* If the button is still being pressed then set the key information */
                  mKeyCurrent = mKeyMap [ 0 ] [ ROW14_KEY ];
                  writeBuffer( mKeyCurrent.keyChars[ KEY_CHAR_NUMERIC ] );
				  writeString( mKeyCurrent.keyChars[ KEY_CHAR_NUMERIC ] );
				  charAvailable = TRUE;
				  
               }

               /* Setting this state re-enables interrupts and makes the keypad ready  */
               /* for use.                                                             */
               KbTimerState = KB_TMR_INTR;
            }
			
			else
			{
				scanKeyPad(debounceScan);

				if (( keyPressScan[ COL3_LOW ] == debounceScan[ COL3_LOW ]) &&
                    ( keyPressScan[ COL4_LOW ] == debounceScan[ COL4_LOW ]) &&
                    ( keyPressScan[ COL7_LOW ] == debounceScan[ COL7_LOW ]))
				{
                  /* Results of the scans are identical */
                  /* Check for simultaneous key presses in multiple columns */

                  numColsPressed = 0;
				  UCHAR colIdx;
                  for ( colIdx = COL3_LOW; colIdx < COL_NUM_DRIVEN; colIdx++ )
                  {
                     if ( keyPressScan[ colIdx ] != DEFAULT_ROW_VAL )
                     {
                        numColsPressed++;
                        colKey = colNum;
						break;
                     }
                  }

                  if ( numColsPressed == 1)
                  {
					 keyValid = FALSE;

                     switch ( keyPressScan[ colIdx ] )
                     {
                        //case MATKB_ROW0:
					 case 0xff:
                           rowKey = ROW0_KEY;
                           keyValid = TRUE;
                           break;

                        //case MATKB_ROW1:
					 case 0x3f:
						   rowKey = ROW1_KEY;
                           keyValid = TRUE;
                           break;

                        //case MATKB_ROW2:
					 case 0x5f:
                           rowKey = ROW2_KEY;
                           keyValid = TRUE;
                           break;

                        //case MATKB_ROW3:
					 case 0x6f:
                           rowKey = ROW3_KEY;
                           keyValid = TRUE;
                           break;

                        //case MATKB_ROW4:
					 case 0x77:
                           rowKey = ROW4_KEY;
                           keyValid = TRUE;
                           break;

                        default:
                           /* A key press has been found in no rows, */
                           /* or more than one row                   */
                           keyValid = FALSE;
                           break;
                     }

					 if ( keyValid == TRUE )
                     {
                        KbEvent = KB_EVENT_KEYPRESS;
						 /* Key down Event Detected */
                        mKeyCurrent = mKeyMap [ colIdx ] [ rowKey ];

                        /* If we are within the character indexing 'window of */
                        /* opportunity' and another key down event occurs,    */
                        /* then the last key down event should be promoted to */
                        /* a key press, and the 'window'closed.               */ 
                        
                        if (( mKeyCurrent.keyChars[KEY_CHAR_NUMERIC] != 
                              keyPrevious.keyChars[KEY_CHAR_NUMERIC] ) &&
                               ( charIndexSupported == TRUE ) )
                        {
                           writeBuffer( keyPrevious.keyChars[ KeyCharIdx ] );
						   writeString( keyPrevious.keyChars[ KeyCharIdx ] );
						   charAvailable = TRUE;
                           charIndexSupported = FALSE;
                        }

                        /* Determine whether typematic repeat should be applied  */
                        /* to this key.                                          */
                        /* Typematic repeat is supported in both alpha and       */
                        /* numeric keyboard modes, but applies to the numeric    */
                        /* character only */
                        if ( ( mKeyCurrent.typematicSupported == TRUE ) &&
                             ( mKeyRepeatEnabled != FALSE ) )
                        {
                           /* Key pressed event detected */
                           /* Generate first occurrence of this character */
                           writeBuffer( mKeyCurrent.keyChars[ KEY_CHAR_NUMERIC ] );
						   writeString( mKeyCurrent.keyChars[ KEY_CHAR_NUMERIC ] );
						   charAvailable = TRUE;

                           /* Initiate next keyboard scan after initial typematic delay */
                           typematicPollCount = 0;
                           KbTimerState = KB_TMR_TYPEMATIC_DELAY;
                        }

						else
                        {   
                           /* Typematic repeat not required */
                           /* Check if Alpha Indexing is relevant to this key */
                           if ( ( mKeyMode == KEY_MODE_ALPHA ) &&
                                ( mKeyCurrent.maxCharIndex > KEY_CHAR_NUMERIC ) )
                           {
                              /* Check if character index required for this press */
                              if ( ( mKeyCurrent.keyChars[KEY_CHAR_NUMERIC] == 
                                     keyPrevious.keyChars[KEY_CHAR_NUMERIC] ) &&
                                   ( charIndexSupported == TRUE ) )
                              {
                                 /* Character indexing required */
                                 /* Handle wrap-around here as well */
                                 // Here is a C++ problem no operator works on enums
								 /*
								 mKeyCharIdx++;
                                 mKeyCharIdx %= mKeyCurrent.maxCharIndex + 1;
                                 mLastKeyDown = mKeyCurrent.keyChars[ mKeyCharIdx ];
								 */
  								 KeyCharIdx++;
                                 KeyCharIdx %= mKeyCurrent.maxCharIndex + 1;
                                 mLastKeyDown = mKeyCurrent.keyChars[ mKeyCharIdx ];


                              }
                              else
                              {
                                 /* Generate First occurrence of this character     */
                                 /* May subsequently need alpha indexing            */
                                 /* in alphanumeric mode, make the first         */
                                 /* character generated a letter                 */
                                 KeyCharIdx = KEY_CHAR_ALPHA1;
                                 mLastKeyDown = mKeyCurrent.keyChars[ KeyCharIdx ];
                              }

							  
                        
                           }
                           else 
                           {
                              /* Generate Only occurrence of this character */
                              writeBuffer( mKeyCurrent.keyChars[ KEY_CHAR_NUMERIC ] );
							  writeString( mKeyCurrent.keyChars[ KEY_CHAR_NUMERIC ] );
							  charAvailable = TRUE;
                           }

                           /* Initiate checking for key release */
                           KbTimerState = KB_TMR_RELEASE_SCAN_DELAY;
                           keyPrevious = mKeyCurrent;
						}
					 }
					 
					 else
                     {
                        /* A key press has been found in no rows, or more than one row */
                        /* Not a valid key press - Set up for key press interrupt      */
                        KbTimerState = KB_TMR_INTR;
                     }
                  }
                  
				  else
                  {
                     /* A key press has been found in no columns, or more than one column */
                     /* Not a valid key press - Set up for key press interrupt            */
                     KbTimerState = KB_TMR_INTR;
                  }
               }
               else
               {
                  /* Results of the scans are different                       */
                  /* Not a valid key press - Set up for key press interrupt   */
                  KbTimerState = KB_TMR_INTR;
               }

            } /* if ( bPowerButton ) ... else ... */


   
				/*
			    //Mine
				if(prevChar!=newChar)
				{
					noChar=1; 
					KbTimerState = KB_TMR_INTR;
					SetTimer(KB_TMR_ID1, KB_TMR_INTR_DELAY, NULL);
				}

				else
				{
					KbEvent = KB_EVENT_KEYPRESS;
					writeBuffer(newChar);
					nReleaseCheck=0;
					KbTimerState = KB_TMR_RELEASE_DELAY;
					SetTimer(KB_TMR_ID1, KB_TMR_RELEASE_INTERVAL, NULL);
		
				}
				*/
			
			
			break;


		case KB_TMR_RELEASE_SCAN_DELAY:

				scanKeyPad(releaseScan); 
				KbEvent = KB_EVENT_KEYRELEASE ;
				 //This is for the safer side of game
				 //Though in the DEBOUNCE state itself the Keypad
				 //is scanned for the presence of the same character,
				 //we need to scan once more in RELEASE state. This
				 //is to avoid the "misbehavior" of Interleaved software 
				 //timer, or even the interrupt based hardware timer
					
				if ( ( releaseScan[ COL3_LOW ] == DEFAULT_ROW_VAL ) &&
                 ( releaseScan[ COL4_LOW ] == DEFAULT_ROW_VAL ) &&
                 ( releaseScan[ COL7_LOW ] == DEFAULT_ROW_VAL ) )
            {
               /* key up event */ 
               /* All keys released */
               /* Check for indexing of alpha characters on this key */
               if ( ( mKeyMode == KEY_MODE_ALPHA ) &&
                    ( mKeyCurrent.maxCharIndex > KEY_CHAR_NUMERIC ) )
               {

                  /* For character indexing to occurr, succesive, valid       */
                  /* presses of the same key must be detected within a        */
                  /* designated time frame.                                   */

                  /* Read the WARNING in the file header regarding use of the */
                  /* keyboard timer !                                         */

                  /* Initiate first character index keyboard poll */
                  //elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_OFF ); //Parallel to KillTimer
                  //elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_CHAR_INDEX_PERIOD ); //Parallel to SetTimer
				  KbTimerState = KB_TMR_CHAR_INDEX_POLL_DELAY;
				  SetTimer(KB_TMR_ID1, KB_TMR_CHAR_INDEX_POLL_INTERVAL, NULL);
				  
				  
				  //key_timer_state = KEY_TIMER_CHAR_INDEX_POLL;
                  indexPollCount = 0;
               }
               else
               {
                  /* Final occurrence of this character has been generated */
                  /* Set up for key press interrupt                        */
                  KbTimerState = KB_TMR_INTR;
				  SetTimer(KB_TMR_ID1, KB_TMR_INTR, NULL);
               }
            }
            
			
			else
            {
               /* A key is still pressed              */
               /* Initiate next check for key release */
               // elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_OFF ); //Paralel to KillTimer
               // elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_RELEASE_SCAN_PERIOD );
				KbTimerState = KB_TMR_RELEASE_SCAN_DELAY;
				SetTimer(KB_TMR_ID1, KB_TMR_RELEASE_SCAN_INTERVAL, NULL);
				

            }
				/*
				if(prevChar!=newChar)
				{
					noChar=1;
					KbTimerState = KB_TMR_INTR;
					SetTimer(KB_TMR_ID1, KB_TMR_INTR_DELAY,NULL);
				}

				else
				{
					noChar=0;
					
					if(nReleaseCheck==1)
					{
						KbEvent = KB_EVENT_KEYRELEASE;
					}
					
					else if(nReleaseCheck>1)
					{
						KbTimerState = KB_TMR_TYPEMATIC_DELAY;
						SetTimer(KB_TMR_ID1, KB_TMR_TYPEMATIC_INTERVAL, NULL);
					}
				}
			
			nReleaseCheck++;
			*/

			break;

		case KB_TMR_TYPEMATIC_DELAY:

            scanKeyPad( typematicScan );

            typematicPollCount++;

            if ( ( typematicScan[ COL3_LOW ] == keyPressScan[ COL3_LOW ] ) &&
                 ( typematicScan[ COL4_LOW ] == keyPressScan[ COL4_LOW ] ) &&
                 ( typematicScan[ COL7_LOW ] == keyPressScan[ COL7_LOW ] ) )
            {
               /* Results of the scans are identical  */
               /* i.e. same key is still pressed      */

               /* Prevent one too many scans */
               if ( typematicPollCount < mKeyDelay[ mKeyRepeatDelay ].numScans )
               {
                  /* Initiate next   poll */
                  
				    
				  //elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_OFF ); //Parallel to KillTimer!
                  //elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_TYPEM_DELAY_SCAN_PERIOD ); //Parallel to SetTimer!
				   KbTimerState = KB_TMR_TYPEMATIC_REPEAT_DELAY;
				   SetTimer(KB_TMR_ID1, KB_TMR_TYPEMATIC_REPEAT_INTERVAL, NULL);
				   
				  
               }
               else
               {
                  /* Same key has been pressed continually for the typematic delay  */
                  /* Generate first repeat                                          */
                  /* Key pressed event */
                  writeBuffer( mKeyCurrent.keyChars[ KEY_CHAR_NUMERIC ] );
				  writeString( mKeyCurrent.keyChars[ KEY_CHAR_NUMERIC ] );
				  charAvailable = TRUE;
                  KbTimerState = KB_TMR_TYPEMATIC_REPEAT_DELAY;
               }
            }
            else
            {
               /* key no longer pressed, initiate checking for key release */
               //elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_OFF );// Parallel to KillTimer!
               //elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_RELEASE_SCAN_PERIOD ); //Parallel to SetTimer
               KbTimerState = KB_TMR_RELEASE_SCAN_DELAY;
			   SetTimer(KB_TMR_ID1, KB_TMR_RELEASE_SCAN_INTERVAL, NULL);
            }

            break; 
			
			/* KEY_TIMER_WAIT_TYPEMATIC_DELAY */
			
			/*My Code*/
		    /*
			KbEvent = KB_EVENT_KEYRELEASE;
			if(!validChar)
			{
				KbTimerState = KB_TMR_INTR;
				SetTimer(KB_TMR_ID1, KB_TMR_INTR, NULL);
			    
				//Roll back the timer expire value to check for debounces
				//KbTimerState = KB_TMR_DEBOUNCE_DELAY;
				//SetTimer(KB_TMR_ID1, KB_TMR_DEBOUNCE_INTERVAL, NULL);
				
			}

			else
			{
				KbTimerState = KB_TMR_REPEAT_DELAY;
				SetTimer(KB_TMR_ID1, KB_TMR_REPEAT_INTERVAL, NULL);
			}
			*/

			break;

		case KB_TMR_TYPEMATIC_REPEAT_DELAY:

			 scanKeyPad( typematicScan );

            if ( ( typematicScan[ COL3_LOW ] == keyPressScan[ COL3_LOW ] ) &&
                 ( typematicScan[ COL4_LOW ] == keyPressScan[ COL4_LOW ] ) &&
                 ( typematicScan[ COL7_LOW ] == keyPressScan[ COL7_LOW ] ) )
            {
               /* Results of the scans are identical                             */
               /* Generate third and subsequent occurrences of numeric character */
               /* key press event */
                writeBuffer( mKeyCurrent.keyChars[ KEY_CHAR_NUMERIC ] );
				writeString( mKeyCurrent.keyChars[ KEY_CHAR_NUMERIC ] );
				charAvailable = TRUE;

               /* Initiate next keyboard scan after typematic repeat period */
               
			   //elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_OFF ); //Parallel to KillTimer()
               /* Need to understand this code*/ 
			   //elan_write_csc( CSC_KEYB_TIMER, m_key_repeat[ m_key_repeat_rate ].keyboard_timer ); /Parallel to SetTimer()
				SetTimer(KB_TMR_ID1, mKeyRepeat[mKeyRepeatRate].keyBoardTimer, NULL);
            }
            else
            {
               /* Key no longer pressed, initiate checking for key release */
               
			   //elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_OFF ); //Parallel of KillTimer!
               //elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_RELEASE_SCAN_PERIOD ); //Parallel of SetTimer!
               KbTimerState = KB_TMR_RELEASE_SCAN_DELAY;
			   SetTimer(KB_TMR_ID1, KB_TMR_RELEASE_SCAN_INTERVAL, NULL);
            }
            
			/*My Code*/
			/*
			if(!validChar)
			{
				KbTimerState = KB_TMR_INTR;
				SetTimer(KB_TMR_ID1, KB_TMR_INTR, NULL);
			    
				//Roll back the timer expire value to check for debounces
				//KbTimerState = KB_TMR_DEBOUNCE_DELAY;
				//SetTimer(KB_TMR_ID1, KB_TMR_DEBOUNCE_INTERVAL, NULL);
				
			}

			else
			{
				AfxMessageBox("Repeating");
				charRepeat = TRUE;
			}*/
			break;

		case KB_TMR_CHAR_INDEX_POLL_DELAY:

			indexPollCount++;

            if ( indexPollCount <= MAX_CHAR_INDEX_POLLS )
            {
               /* We are still within the character indexing 'window of       */
               /* opportunity', check for any keys down                       */
               scanKeyPad( indexScan );

               if ( ( indexScan[ COL3_LOW ] != DEFAULT_ROW_VAL ) ||
                    ( indexScan[ COL4_LOW ] != DEFAULT_ROW_VAL ) ||
                    ( indexScan[ COL7_LOW ] != DEFAULT_ROW_VAL ) )
               {
                  /* key down event, initiate debounce */
                  /* and validation process. */
                  //elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_OFF ); //Parallel to KillTimer
                  //elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_DEBOUNCE ); //Parallel to SetTimer
                  KbTimerState = KB_TMR_DEBOUNCE_DELAY;
				  SetTimer(KB_TMR_ID1, KB_TMR_DEBOUNCE_INTERVAL, NULL);
                  charIndexSupported = TRUE;
               }
               else
               {
                  /* No keys down, Initiate next index poll                   */
                  //elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_OFF ); //Parallel to KillTimer
                  //elan_write_csc( CSC_KEYB_TIMER, KEYB_TIMER_CHAR_INDEX_PERIOD ); //Parallel to SetTimer
				   KbTimerState = KB_TMR_CHAR_INDEX_POLL_DELAY;
				   SetTimer(KB_TMR_ID1, KB_TMR_CHAR_INDEX_POLL_INTERVAL, NULL);

               }

            }
            else
            {
               /* Time frame during which presses will be considered for      */
               /* indexing purposes has expired without any key presses       */
               /* being detected.                                             */
               /* Accept the last key down as key press event                 */
               writeBuffer( mKeyCurrent.keyChars[ mKeyCharIdx ] );
			   writeString( mKeyCurrent.keyChars[ mKeyCharIdx ] );
			   charAvailable = TRUE;
               charIndexSupported = FALSE;
               KbTimerState = KB_TMR_INTR;
			   SetTimer(KB_TMR_ID1, KB_TMR_INTR_INTERVAL, NULL);
            } 

			if(!validChar)
				break;
		default:
			break;

		}


	}
	
	else if (ID == KB_TMR_ID2)
	{
		CEdit *Ctl1 = (CEdit*)GetDlgItem(IDC_STATIC_EVENT);
		
		switch(KbEvent)
		{
		case KB_EVENT_KEYPRESS:
			Ctl1->SetWindowText("KB_EVENT_KEYPRESS");
			break;

		case KB_EVENT_KEYRELEASE:
			Ctl1->SetWindowText("KB_EVENT_KEYRELEASE");
			break;

		default:
			Ctl1->SetWindowText("Waiting For Key Event");
			break;
		}


		if(charAvailable)
		{
			
			charAvailable = FALSE;

			CString str = _T(" ");
		
			char rChar = readChar();

			str.Format("%c",rChar);
			CEdit *Ctl = (CEdit*)GetDlgItem (IDC_EDIT1);
			Ctl->SetWindowText(str);
			SetDlgItemText(IDC_EDIT_TEXT,finalTextBuffer);

			//SetDlgItemInt(IDC_CHECK1,1);
			
			CButton *Btn[16];
			
			Btn[1] = (CButton*)GetDlgItem(IDC_CHECK1);
			Btn[2] = (CButton*)GetDlgItem(IDC_CHECK2);
			Btn[3] = (CButton*)GetDlgItem(IDC_CHECK3);
			Btn[4] = (CButton*)GetDlgItem(IDC_CHECK4);
			Btn[5] = (CButton*)GetDlgItem(IDC_CHECK5);
			Btn[6] = (CButton*)GetDlgItem(IDC_CHECK6);
			Btn[7] = (CButton*)GetDlgItem(IDC_CHECK7);
			Btn[8] = (CButton*)GetDlgItem(IDC_CHECK8);
			Btn[9] = (CButton*)GetDlgItem(IDC_CHECK9);
			Btn[10] = (CButton*)GetDlgItem(IDC_CHECK10);
			Btn[11] = (CButton*)GetDlgItem(IDC_CHECK11);
			Btn[12] = (CButton*)GetDlgItem(IDC_CHECK12);
			Btn[13] = (CButton*)GetDlgItem(IDC_CHECK13);
			Btn[14] = (CButton*)GetDlgItem(IDC_CHECK14);
			Btn[15] = (CButton*)GetDlgItem(IDC_CHECK15);
			
		}
	}
	
	

/*		if(KbTimerState = KB_TMR_INTR)
		{
			// This timer state and this for loop are spurious!. I am just
			// trying this 5ms timer, instead of hardware interrupts. It works fine
			// when windows is not occupied with other jobs
						
			//scan_keypad( keypress_scan );
			
			//In actual, the scan_keypad function can be used. But just
			//avoiding a function jump in a timer event
			 
			for(colSet = MIN_COL_VAL; colSet <= MAX_COL_VAL; colSet++)
			{
				Out32( COL_WRITE_PORT, colArr[colSet-1] );
				pause();
				keyVal[colSet-1] = Inp32(ROW_READ_PORT);

				if(keyVal[colSet-1] != DEFAULT_ROW_VAL)
				{
					charVal = ((char)keyVal[colSet-1] && 0xF8) | colSet;
					validChar =1;
					prevChar = charVal;
					//writeBuffer(charVal);
		
					switch(charVal)
					{
					
					}
					
				}
				
				else
				{
					validChar =0;
				}
			
			}

			// Check for multiple row and multiple column press
			if(validChar)
			{
				KbTimerState = KB_TMR_DEBOUNCE_DELAY;
				SetTimer(KB_TMR_ID1, KB_TMR_DEBOUNCE_INTERVAL, NULL);
			}

		}

		
		if(KbTimerState == KB_TMR_DEBOUNCE_DELAY)
		{
			if(validChar)
			{
				scanKeyPad(&newChar);

				if(prevChar!=newChar)
				{
					noChar=1; 
					KbTimerState = KB_TMR_INTR;
					SetTimer(KB_TMR_ID1, KB_TMR_INTR_DELAY, NULL);
				}

				else
				{
					KbEvent = KB_EVENT_KEYPRESS;
					pushBuffer(newChar);
					nReleaseCheck=0;
					KbTimerState = KB_TMR_RELEASE_DELAY;
					SetTimer(KB_TMR_ID1, KB_TMR_RELEASE_INTERVAL, NULL);
					
				}
				
			}

			
		}

		
		if(KbTimerState == KB_TMR_RELEASE_DELAY)
		{
			
			
			scanKeyPad(&newChar); 
				 
				 //This is for the safer side of game
				 //Though in the DEBOUNCE state itself the Keypad
				 //is scanned for the presence of the same character,
				 //we need to scan once more in RELEASE state. This
				 //is to avoid the "misbehavior" of Interleaved software 
				 //timer, or even the interrupt based hardware timer
				          
				if(prevChar!=newChar)
				{
					noChar=1;
					KbTimerState = KB_TMR_INTR;
					SetTimer(KB_TMR_ID1, KB_TMR_INTR_DELAY,NULL);
				}

				else
				{
					noChar=0;
					
					if(nReleaseCheck==1)
					{
						KbEvent = KB_EVENT_KEYRELEASE;
					}
					
					else if(nReleaseCheck>1)
					{
						KbTimerState = KB_TMR_TYPEMATIC_DELAY;
						SetTimer(KB_TMR_ID1, KB_TMR_TYPEMATIC_INTERVAL, NULL);
					}
				}
			
			nReleaseCheck++;
		}



		if(KbTimerState == KB_TMR_TYPEMATIC_DELAY)
		{
			
			KbEvent = KB_EVENT_KEYRELEASE;
			if(!validChar)
			{
				KbTimerState = KB_TMR_INTR;
				SetTimer(KB_TMR_ID1, KB_TMR_INTR, NULL);
			    
				//Roll back the timer expire value to check for debounces
				//KbTimerState = KB_TMR_DEBOUNCE_DELAY;
				//SetTimer(KB_TMR_ID1, KB_TMR_DEBOUNCE_INTERVAL, NULL);
				
			}

			else
			{
				KbTimerState = KB_TMR_REPEAT_DELAY;

				SetTimer(KB_TMR_ID1, KB_TMR_REPEAT_INTERVAL, NULL);
			}


		}

		if(KbTimerState == KB_TMR_REPEAT_DELAY)
		{
			if(!validChar)
			{
				KbTimerState = KB_TMR_INTR;
				SetTimer(KB_TMR_ID1, KB_TMR_INTR, NULL);
			    
				//Roll back the timer expire value to check for debounces
				//KbTimerState = KB_TMR_DEBOUNCE_DELAY;
				//SetTimer(KB_TMR_ID1, KB_TMR_DEBOUNCE_INTERVAL, NULL);
				
			}

			else
			{
				AfxMessageBox("Repeating");
				charRepeat = TRUE;
			}
		}
			
*/
		


	
	
	//Validation Timer
	
	/*else if (ID == KB_TMR_ID2)
	{
	
	}
	*/
	
	/*m_th1->ResumeThread();*/

}


void CMcdKeysDlg::OnDestroy()
{
	KillTimer(1);
	KillTimer(2);
}

/*----------------------------------------------------------------------------*/
/* pause                                                                      */
/*                                                                            */
/* Passed        : None                                                       */
/* Returned      : None                                                       */
/*                                                                            */
/* Pause an (undefined) period of time sufficient to allow voltage            */
/* keyboard input signals to stabilise.                                       */
/*----------------------------------------------------------------------------*/

static void pause( void )
{
   short i;
   short sum;

   sum = 0;

   /* arbitrary 'small' time delay */
   for ( i = 0; i < 10; i++ )
   {
       sum = sum + i;
   }

} /* pause */

//Pass an array of fixed size
//MCD guys have written quite portable code. But not required.
//There the for loop in turn contains a switch-case to identify
//the column port address. Its an enum. But here the columns
//are sequential. nothing of that sort is required. Just a for
//loop is enoughYYY


void scanKeyPad(UCHAR *keyInfo)
{
	for(colSet = MIN_COL_VAL; colSet <= MAX_COL_VAL; colSet++)
	{
		Out32( COL_WRITE_PORT, colArr[colSet-1] );

		pause();
		
		keyInfo[colSet-1] = (UCHAR)Inp32(ROW_READ_PORT);

	}
}



/*
static void scan_keypad1( UCHAR *keyInfo )
{

   tColDrive column_drive;

   // For each active column, the sequence will be:            
   // Clear selected column only, Set all others.              
   // Allow a settling time                                    
   // Read keyboard rows, mask result and update target array  

   for ( column_drive = COL3_LOW; column_drive < COL_NUM_DRIVEN; column_drive++ )
   {
      switch ( column_drive )
      {
         case COL3_LOW:
            Out32( COL_WRITE_PORT, ~MATKB_COL0 );
            pause();
            keyInfo[COL3_LOW] = (UCHAR)Inp32 ( ROW_READ_PORT ) & ACTIVE_ROWS;
            break;

         case COL4_LOW:
            Out32( COL_WRITE_PORT, ~MATKB_COL1 );
            pause();
            keyInfo[ COL4_LOW ] = (UCHAR)Inp32 ( ROW_READ_PORT ) & ACTIVE_ROWS;
            break;

         case COL7_LOW:
            Out32( COL_WRITE_PORT, ~MATKB_COL2 );
            pause();
            keyInfo[COL7_LOW ] = (UCHAR)Inp32 ( ROW_READ_PORT ) & ACTIVE_ROWS;
            break;

         default:
            // Intentionally blank 
            break;
      }
   }

} */


/*
void CMcdKeysDlg::OnReleasedcaptureSlider1(NMHDR* pNMHDR, LRESULT* pResult) 
{
//	char str[20]=" ";
//	wsprintf(str, "%d", pNMHDR->code);
//	MessageBox(str);
	CSliderCtrl *Clt = (CSliderCtrl*)GetDlgItem (IDC_SLIDER1);
	if (Clt)
	{
		int iPos = Clt->GetPos ();
	}
		
	*pResult = 0;
}
*/

		
